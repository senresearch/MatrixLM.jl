var documenterSearchIndex = {"docs":
[{"location":"functions/#Index","page":"Types and Functions","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"","category":"page"},{"location":"functions/#Description","page":"Types and Functions","title":"Description","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [MatrixLM]","category":"page"},{"location":"functions/#MatrixLM.MLMplots","page":"Types and Functions","title":"MatrixLM.MLMplots","text":"Mlm_plots(tStats::Matrix{Float64}, n::Int64, colNames::Matrix{String}})\n\nPlot the t-statistics of the coefficients. #Inputs: tStats::Matrix{Float64}: a matrix of t-statistics n::Int64: the number of rows in the t-statistics MatrixLM colNames::Matrix{string}: the column names of the columns in the t-statistics matrix.\n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.Mlm","page":"Types and Functions","title":"MatrixLM.Mlm","text":"Mlm(B::Array{Float64,2}, varB::Array{Float64,2}, sigma::Array{Float64,2},    \n    data::RawData, weights, targetType, lambda::Float64)\n\nType for storing the results of an mlm model fit. \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.Predictors","page":"Types and Functions","title":"MatrixLM.Predictors","text":"Predictors(X::AbstractArray{Float64,2}, Z::AbstractArray{Float64,2},\n           hasXIntercept::Bool, hasZIntercept::Bool)\n\nType for storing predictor (covariate) matrices. Also stores boolean  variables hasXIntercept and hasZIntercept (if they are not supplied, they  default to false). \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.RawData","page":"Types and Functions","title":"MatrixLM.RawData","text":"RawData(response::Response, predictors::Predictors)\n\nType for storing response and predictor matrices\n\nAlso stores dimensions of matrices as n, m, p, and q. \n\nn : number of rows of X = number of rows of Y\nm : number of rows of Z = number of columns of Y\np : number of columns of X\nq : number of columns of Z\n\nThe constructor will compute n, m, p, and q based on the response and  predictor matrices and assert that they are consistent. \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.Response","page":"Types and Functions","title":"MatrixLM.Response","text":"Response(Y::AbstractArray{Float64,2})\n\nType for storing response matrix\n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.add_intercept-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.add_intercept","text":"add_intercept(A::AbstractArray{Float64,2})\n\nInsert an intercept column (column of ones) at the beginning of a 2d array. \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with an intercept column\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_coeffs-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_coeffs","text":"calc_coeffs(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, \n            Z::AbstractArray{Float64,2}, XTX::AbstractArray{Float64,2}, \n            ZTZ::AbstractArray{Float64,2})\n\nCalculates the the coefficient estimates\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, with all  categorical variables coded in appropriate contrasts\nY::AbstractArray{Float64,2}: The multivariate response\nZ::AbstractArray{Float64,2}: The column covariates, with all categorical variables coded in appropriate contrasts\nXTX::AbstractArray{Float64,2}: X*transpose(X) product as a 2d array of floats \nZTZ::AbstractArray{Float64,2}: Z*transpose(Z) product as a 2d array of floats \n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_preds!-NTuple{4, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_preds!","text":"calc_preds!(preds::AbstractArray{Float64,2}, \n            X::AbstractArray{Float64,2}, \n            Z::AbstractArray{Float64,2}, \n            B::AbstractArray{Float64,2})\n\nPredict values in place\n\nArguments\n\npreds::AbstractArray{Float64,2}: The predicted values, to be  updated in place\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized  as necessary\nB::AbstractArray{Float64,2}: Coefficient estimates\n\nValue\n\nNone; updates predicted values in place. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_preds-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_preds","text":"calc_preds(X::AbstractArray{Float64,2}, \n           Z::AbstractArray{Float64,2}, \n           B::AbstractArray{Float64,2})\n\nPredict values\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized  as necessary\nB::AbstractArray{Float64,2}: Coefficient estimates\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_resid!-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_resid!","text":"calc_resid!(resid::AbstractArray{Float64,2}, \n                 X::AbstractArray{Float64,2}, \n                 Y::AbstractArray{Float64,2}, \n                 Z::AbstractArray{Float64,2}, \n                 B::AbstractArray{Float64,2})\n\nCalculate residuals in place\n\nArguments\n\nresid: 2d array of floats consisting of the residuals, to be updated in  place\nX: 2d array of floats consisting of the row covariates, standardized as  necessary\nY: 2d array of floats consisting of the multivariate response  observations, standardized as necessary\nZ: 2d array of floats consisting of the column covariates, standardized  as necessary\nB: 2d array of floats consisting of coefficient estimates\n\nValue\n\nNone; updates residuals in place. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_resid-NTuple{4, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_resid","text":"calc_resid(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, \n       Z::AbstractArray{Float64,2}, B::AbstractArray{Float64,2})\n\nCalculate residuals\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nY::AbstractArray{Float64,2}: The multivariate response observations, standardized as necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized as necessary\nB::AbstractArray{Float64,2}: The coefficient estimates\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_sigma-Tuple{AbstractMatrix{Float64}, AbstractString}","page":"Types and Functions","title":"MatrixLM.calc_sigma","text":"calc_sigma(resid::AbstractArray{Float64,2}, targetType::AbstractString)\n\nEstimates variance of errors and the shrinkage coefficient, with variance  shrinkage. \n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType::AbstractString: Indicating the target type toward which to shrink the  variance. Acceptable inputs are \"A\", \"B\", \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nTuple\n\nsigma: 2d array of floats; shrunk estimated variance of errors\nlambda: floating scalar; estimated shrinkage coefficient  (0 = no shrinkage, 1 = complete shrinkage)\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_sigma-Tuple{AbstractMatrix{Float64}, Nothing}","page":"Types and Functions","title":"MatrixLM.calc_sigma","text":"calc_sigma(resid::AbstractArray{Float64,2}, targetType::Nothing)\n\nEstimates variance of errors and the shrinkage coefficient, without variance  shrinkage. \n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType : nothing\n\nValue\n\nTuple\n\nsigma: 2d array of floats; estimated variance of errors\nlambda: 0.0\n\nSome notes\n\nSince this version of calc_sigma does not implement variance shrinkage, the  shrinkage coefficient lambda is 0. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_var-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_var","text":"calc_var(X::AbstractArray{Float64,2}, Z::AbstractArray{Float64,2},\n         XTX::AbstractArray{Float64,2}, ZTZ::AbstractArray{Float64,2}, \n         sigma::AbstractArray{Float64,2})\n\nCalculate the variance (diagonal of the covariance matrix) of the coefficient  estimates. \n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, with all  categorical variables coded in appropriate contrasts\nZ::AbstractArray{Float64,2}: The column covariates, with all  categorical variables coded in appropriate contrasts\nXTX::AbstractArray{Float64,2}: X*transpose(X) product as a 2d array of floats \nZTZ::AbstractArray{Float64,2}: Z*transpose(Z) product as a 2d array of floats \nsigma::AbstractArray{Float64,2}: 2d array of floats consisting of the estimated sigma\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.center-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.center","text":"center(A::AbstractArray{Float64,2})\n\nCenters columns of a 2d array\n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.coef-Tuple{Mlm}","page":"Types and Functions","title":"MatrixLM.coef","text":"coef(MLM::Mlm)\n\nExtracts coefficients from Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.contr","page":"Types and Functions","title":"MatrixLM.contr","text":"contr(df::DataFrames.DataFrame, cVars::AbstractArray{Symbol,1}, \n      cTypes::AbstractArray{String,1}=repeat([\"treat\"], inner=length(cVars)), \n      trtRefs::AbstractArray= repeat([nothing], inner=length(cVars)))\n\nConverts categorical variables in a DataFrame to specified contrast types.  All other variables are left as-is. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncTypes::AbstractArray{String,1}: 1d array of character strings of the same length as cVars,  indicating the types of contrasts to use. Defaults to treatment contrasts  (\"treat\") for all variables in cVars. Other options include \"sum\" for sum  contrasts, \"noint\" for treatment contrasts with no intercept, and  \"sumnoint\" for sum contrasts with no intercept. For \"treat\" cTypes, you  can also specify the level to use as the reference treatment using trtRefs. \ntrtRefs::AbstractArray: optional 1d array of character strings of the same length as  cVars, specifying the level to use as the references for treatment  contrasts. Defaults to nothing for all variables in cVars.\n\nValue\n\nDataFrame with same variables as the original DataFrame, but categorical  variables converted to dummy contrasts. \n\nSome notes\n\nIf cVars consists of only an empty Symbol, i.e. cVars=[Symbol()], this  will signal to the function that no contrasts should be created. The  original DataFrame will be returned. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.cov_est-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.cov_est","text":"cov_est(resid::AbstractArray{Float64,2})\n\nEstimates error variance and its variance/covariance\n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\n\nValue\n\nTuple\n\nest: 2d array of floats; estimate\nvarest: 2d array of floats; variance/covariance estimate\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.design_matrix-Tuple{Any, DataFrames.DataFrame, Dict{Symbol, StatsModels.AbstractContrasts}}","page":"Types and Functions","title":"MatrixLM.design_matrix","text":"design_matrix(f, df::DataFrame,cntrst::Dict{Symbol, AbstractContrasts})\n\nBuild design matrix.\n\nArguments\n\nf: formula for matrixLM, use @mlmFormula\ndf::DataFrames.DataFrame: DataFrame of variables\ncntrst::Dict{Symbol, AbstractContrasts}: Encoding method for categorical or ordinal variables\n\n\n\ndesign_matrix(f, df::DataFrame, cntrst::Vector)\n\nBuild design matrix.\n\nArguments\n\nf: formula for matrixLM, use @mlmFormula\ndf::DataFrames.DataFrame: DataFrame of variables\ncntrst: An vactor containing tuples of variable and its encoding function.\n\n\n\ndesign_matrix(f, df::DataFrame)\n\nDefault design matrix, all the categorical variables would be dummy coded.\n\nArguments\n\nf: formula for matrixLM, use @mlmFormula\ndf::DataFrames.DataFrame: DataFrame of variables\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::AbstractArray{Float64,2})\n\nGet the diagonal of a 2d array of floats. This just calls the base diag  function.\n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\n1d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{AbstractVector{Float64}}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::AbstractArray{Float64,1})\n\nGet the diagonal of a 1d array of floats. Behaves like an identity function  (returns itself). \n\nArguments\n\nA::AbstractArray{Float64,1}: 1d array of floats\n\nValue\n\n1d array of floats \n\nSome notes\n\nOriginally intended for use when A is a 1 by 1 array, so may have unintended  consequences for a 1d array of length > 1. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{Float64}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::Float64)\n\nGet the diagonal of a single scalar (float) value. Behaves like an identity  function (returns itself). \n\nArguments\n\nA::Float64: floating scalar\n\nValue\n\nFloating scalar\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.fitted-Tuple{Mlm}","page":"Types and Functions","title":"MatrixLM.fitted","text":"fitted(MLM::Mlm)\n\nCalculate fitted values of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\n\nValue\n\nResponse object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_X-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_X","text":"get_X(data::RawData)\n\nExtract X matrix from RawData object \n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_Y-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_Y","text":"get_Y(data::RawData)\n\nExtract Y matrix from RawData object\n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_Z-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_Z","text":"get_Z(data::RawData)\n\nExtract Z matrix from RawData object\n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_dummy-Tuple{DataFrames.DataFrame, Symbol, String, Nothing}","page":"Types and Functions","title":"MatrixLM.get_dummy","text":"get_dummy(df::DataFrames.DataFrame, cVar::Symbol, \n          cType::String, trtRef::Nothing)\n\nConvert categorical variable to dummy indicators using specified contrast  type. This covers all cases except for treatment contrasts with a specified  reference level. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncType::String: character string indicating the type of contrast to use for cVar\ntrtRef::Nothing: nothing\n\nValue\n\nDataFrame of dummy variables for the specified categorical variable\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_dummy-Tuple{DataFrames.DataFrame, Symbol, String, String}","page":"Types and Functions","title":"MatrixLM.get_dummy","text":"get_dummy(df::DataFrames.DataFrame, cVar::Symbol, \n          cType::String, trtRef::String)\n\nConvert categorical variables to for treatment contrasts with a specified  reference level. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncType::String: character string indicating the type of contrast to use for cVar\ntrtRef::String: character string specifying the level in cVar to use as the reference \n\nValue\n\nDataFrame of dummy variables for the specified categorical variable\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.kron_diag-Tuple{Any, Any}","page":"Types and Functions","title":"MatrixLM.kron_diag","text":"kron_diag(A, B)\n\nCompute the diagonal of the Kronecker product of arrays or scalars\n\nArguments\n\nA: square 2d array of floats, a 1d array of floats, or a scalar\nB: square 2d array of floats, a 1d array of floats, or a scalar\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.mlm","text":"mlm(data::RawData; addXIntercept::Bool=true, addZIntercept::Bool=true, weights=nothing, targetType=nothing)\n\nMatrix linear model using least squares method. Column weighted least squares  and shrinkage of the variance of the errors are options. \n\nArguments\n\ndata::RawData: RawData object\n\nKeyword arguments\n\naddXIntercept::Bool : boolean flag indicating whether or not to include an X  intercept (row main effects). Defaults to true. \naddZIntercept::Bool : boolean flag indicating whether or not to include a Z  intercept (column main effects). Defaults to true. \nweights : 1d array of floats to use as column weights for Y, or nothing.  If the former, must be the same length as the number of columns of Y.  Defaults to nothing. \ntargetType : string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". Defaults to nothing. \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_fit-Tuple{RawData, Nothing, Any}","page":"Types and Functions","title":"MatrixLM.mlm_fit","text":"mlm_fit(data::RawData, weights::Nothing, targetType)\n\nMatrix linear model using least squares method. Optionally incorporates  shrinkage of the variance of the errors. \n\nArguments\n\ndata::RawData: RawData object\nweights::Nothing: nothing\ntargetType: string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_fit-Tuple{RawData, Vector{Float64}, Any}","page":"Types and Functions","title":"MatrixLM.mlm_fit","text":"mlm_fit(data::RawData, weights::Array{Float64,1}, targetType)\n\nMatrix linear model using column weighted least squares method. Optionally  incorporates shrinkage of the variance of the errors. \n\nArguments\n\ndata::RawData : RawData object\nweights::Array{Float64,1} : 1d array of floats to use as column weights for Y. Must be the  same length as the number of columns of Y. \ntargetType : string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_perms","page":"Types and Functions","title":"MatrixLM.mlm_perms","text":"mlm_perms(data::RawData, nPerms::Int64=1000; \n          permFun::Function=shuffle_rows, \n          addXIntercept::Bool=true, addZIntercept::Bool=true, \n          weights=nothing, targetType=nothing, isMainEff::Bool=false)\n\nObtains permutation p-values for MLM t-statistics. \n\nArguments\n\ndata::RawData: RawData object\nnPerms::Int64=1000: Number of permutations. Defaults to 1000.\n\nKeyword arguments\n\npermFun::Function: function used to permute Y. Defaults to shuffle_rows  (shuffles rows of Y). \naddXIntercept::Bool=true: Boolean flag indicating whether or not to include an X  intercept (row main effects). Defaults to true. \naddZIntercept::Bool=true: Boolean flag indicating whether or not to include a Z  intercept (column main effects). Defaults to true. \nweights: 1d array of floats to use as column weights for Y, or nothing.  If the former, must be the same length as the number of columns of Y.  Defaults to nothing. \ntargetType: string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". Defaults to nothing.\n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries \nisMainEff::Bool: boolean flag indicating whether or not to include p-values for  the main effects\n\nValue\n\nTuple\n\ntStats: 2d array of floats; t-statistics\npvals: 2d array of floats; permutation p-values\n\nSome notes\n\nPermutations are computed in parallel when possible. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.perm_pvals","page":"Types and Functions","title":"MatrixLM.perm_pvals","text":"perm_pvals(fun::Function, data::RawData, nPerms::Int64=1000; \n           permFun::Function=shuffle_rows, funArgs...)\n\nObtains permutation p-values. \n\nArguments\n\nfun::Function: function that returns a test statistic\ndata::RawData: RawData object\nnPerms::Int64: number of permutations. Defaults to 1000.\n\nKeyword arguments\n\npermFun::Function: function used to permute Y. Defaults to shuffle_rows  (shuffles rows of Y). \nfunArgs: variable keyword arguments to be passed into fun\n\nValue\n\nTuple\n\ntestStats: 2d array of floats; t-statistics\npvals: 2d array of floats; permutation p-values\n\nSome notes\n\nPermutations are computed in parallel when possible. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.predict","page":"Types and Functions","title":"MatrixLM.predict","text":"predict(MLM::Mlm, newPredictors::Predictors=MLM.data.predictors)\n\nCalculates new predictions based on Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nnewPredictors::Predictors: Predictors object. Defaults to the data.predictors field  in the Mlm object used to fit the model. \n\nValue\n\nResponse object\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.remove_intercept-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.remove_intercept","text":"remove_intercept(A::AbstractArray{Float64,2})\n\nRemove the intercept column, assumed to be the first column of a 2d array. \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A without the intercept column\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.resid","page":"Types and Functions","title":"MatrixLM.resid","text":"resid(MLM::Mlm, newData::RawData=MLM.data)\n\nCalculates residuals of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nnewData::RawData: RawData object. Defaults to the data field in the Mlm object  used to fit the model. \n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.shrink_sigma-Tuple{AbstractMatrix{Float64}, String}","page":"Types and Functions","title":"MatrixLM.shrink_sigma","text":"shrink_sigma(resid::AbstractArray{Float64,2}, targetType::String)\n\nEstimates variance of errors and the shrinkage coefficient\n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType::String: string indicating the target type toward which to shrink the  variance. Acceptable inputs are \"A\", \"B\", \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nTuple\n\nsigma: 2d array of floats; shrunk estimated variance of errors\nlambda: floating scalar; estimated shrinkage coefficient  (0 = no shrinkage, 1 = complete shrinkage)\n\nReference\n\nLedoit, O., & Wolf, M. (2003). Improved estimation of the covariance matrix      of stock returns with an application to portfolio selection. Journal of      empirical finance, 10(5), 603-621.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.shuffle_cols-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.shuffle_cols","text":"shuffle_cols(A::AbstractArray{Float64,2})\n\nShuffles columns of a 2d array \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with columns shuffled\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.shuffle_rows-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.shuffle_rows","text":"shuffle_rows(A::AbstractArray{Float64,2})\n\nShuffles rows of a 2d array \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with rows shuffled\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.t_stat","page":"Types and Functions","title":"MatrixLM.t_stat","text":"t_stat(MLM::Mlm, isMainEff::Bool=false)\n\nCalculates t-statistics of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nisMainEff::Bool : boolean flag indicating whether or not to include t-statistics  for the main effects\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.@mlmFormula-Tuple{Any}","page":"Types and Functions","title":"MatrixLM.@mlmFormula","text":"mlmFormula(ex)\n\nCapture and parse a formula expression for matrix linear model.\n\n\n\n\n\n","category":"macro"},{"location":"moreExamples/#Modelling-ordinal-data","page":"More examples","title":"Modelling ordinal data","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"For this part our X matrix has only one ordinal variable(catvar1) from 1 to 5. The encoding method for ordinal variable is SeqDiffCoding() from package StatsModels","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"using StatsModels","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"levels = unique(X_df.catvar1)\nencoding = StatsModels.ContrastsMatrix(SeqDiffCoding(), levels).matrix\nencoding_intercept = inv(hcat(ones(5,1),encoding))\nX2 = reduce(vcat,transpose.(map(x -> encoding_intercept[x,:], X_df.catvar1)))","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"p = size(X2)[2]\nn = 100\nm = 250\nq = 20","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# Number of column covariates\nZ2 = rand(m,q)\nB2 = rand(-5:5,p,q)\nE2 = randn(n,m)\nY2 = X2*B2*transpose(Z2)+E2","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"dat2 = RawData(Response(Y2), Predictors(X2, Z2))","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"est2 = mlm(dat2)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"heatmap(coef(est2))","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"(Image: svg)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"heatmap(B2)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"(Image: svg)","category":"page"},{"location":"moreExamples/#Case-study:-metabolomics-analysis","page":"More examples","title":"Case study: metabolomics analysis","text":"","category":"section"},{"location":"moreExamples/#Metabolomic-signatures-of-NAFLD","page":"More examples","title":"Metabolomic signatures of NAFLD","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"Reference: Study ID ST001710","category":"page"},{"location":"moreExamples/#Background","page":"More examples","title":"Background","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"Nonalcoholic fatty liver disease (NAFLD) is a progressive liver disease that is strongly associated with type 2 diabetes.  In this demo, we will apply matrix linear models to this study.","category":"page"},{"location":"moreExamples/#Libraries","page":"More examples","title":"Libraries","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"using LinearAlgebra,StatsModels\nusing MatrixLM\nusing CSV, DataFrames\nusing StatsBase\nusing Random\nusing Plots, FreqTables","category":"page"},{"location":"moreExamples/#Data-description","page":"More examples","title":"Data description","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"The data was collected from workbench. After we performed data wrangling to extract the necessary information: clinical information, metabolites profiles and metabilites attributes, three data files would be involved in this Demonstration.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"For the metabolomic data(Y), we have totally 68 different triglycerides for totally 473 subjects. ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"For each triglyceride(Z), we have the number of carbon atom number and total double bound number.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"For each subject(X), we have following 7 clinical variables. ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"Variables for each subject:    ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-T2DM => type 2 diabetes mellitus (DummyCoding) ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-Kleiner_Steatosis => Stage of Non-Alcoholic Fatty Liver Disease (NAFLD)  (EffectsCoding)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-Inflammation => Inflammation status. (From 1 to 3)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-NAS => NAS score (NAFLD Activity Score) represents the sum of scores for steatosis, lobular -inflammation, and ballooning, and ranges from 0-8.   ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-Platelets_E10_9_per_L => platelets count (10‚Åπ/L)   ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-Liver_ALT => alanine aminotransferase test (ALT) level   ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-Liver_AST => aspartate aminotransferase test (AST) level   ","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"-AST_ALT_Ratio => AST/ALT ratio  useful in medical diagnosis   ","category":"page"},{"location":"moreExamples/#Input-dataset","page":"More examples","title":"Input dataset","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# loading the data\nclinicalDF = CSV.read(\"../../data/processed/ST001710_ClinicalCovariates.csv\", DataFrame)\nmetabolitesTG = CSV.read(\"../../data/processed/MetaboTG.csv\", DataFrame)\nrefTG = CSV.read(\"../../data/processed/refTriglycerides.csv\", DataFrame);","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"print(describe(clinicalDF))","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"print(describe(refTG)) # Total carbon number and total double bound","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"freqtable(refTG.Total_DB)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"10-element Named Vector{Int64}\nDim1  ‚îÇ \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n0     ‚îÇ  9\n1     ‚îÇ  9\n2     ‚îÇ 13\n3     ‚îÇ 11\n4     ‚îÇ  9\n5     ‚îÇ  8\n6     ‚îÇ  6\n7     ‚îÇ  2\n8     ‚îÇ  2\n9     ‚îÇ  2","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"freqtable(refTG.Total_C)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"12-element Named Vector{Int64}\nDim1  ‚îÇ \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n45    ‚îÇ  1\n47    ‚îÇ  3\n48    ‚îÇ  6\n49    ‚îÇ  4\n50    ‚îÇ 10\n51    ‚îÇ  5\n52    ‚îÇ 12\n53    ‚îÇ  4\n54    ‚îÇ 12\n55    ‚îÇ  1\n56    ‚îÇ 10\n58    ‚îÇ  3","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"From the frequency table above, the distribution of Z is inbalanced and we need to transform them.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# Transformation\nrefTG2 = copy(refTG)\nrefTG2.Total_DB[findall(refTG.Total_DB.>=6)] .=6;\nrefTG2.Total_C[findall(refTG.Total_C.<=50)] .=1;\nrefTG2.Total_C[findall(refTG.Total_C.>50 .&& refTG.Total_C.<=55)] .=2;\nrefTG2.Total_C[findall(refTG.Total_C.>55)] .=3;","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"freqtable(refTG2.Total_DB)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"7-element Named Vector{Int64}\nDim1  ‚îÇ \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n0     ‚îÇ  9\n1     ‚îÇ  9\n2     ‚îÇ 13\n3     ‚îÇ 11\n4     ‚îÇ  9\n5     ‚îÇ  8\n6     ‚îÇ 12","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"freqtable(refTG2.Total_C)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"3-element Named Vector{Int64}\nDim1  ‚îÇ \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n1     ‚îÇ 24\n2     ‚îÇ 34\n3     ‚îÇ 13","category":"page"},{"location":"moreExamples/#Model-Decision","page":"More examples","title":"Model Decision","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"Our first model would be simple, with only one variable(T2DM) are included into the design matrix.","category":"page"},{"location":"moreExamples/#Model:-T2DM","page":"More examples","title":"Model: T2DM","text":"","category":"section"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# Generate X matrix\ncontrasts = Dict(:T2DM => EffectsCoding(base = \"N\"))\nfrml = @formula(0 ~  T2DM).rhs\n# mf = ModelFrame(@formula(y ~ 1 + Sex).rhs, dfInd)\nX_1 = modelmatrix(frml, clinicalDF, hints = contrasts);","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# Generate Z matrix\ncontrasts = Dict(:Total_C => StatsModels.FullDummyCoding())\nfrml = @formula(0 ~ Total_C).rhs\n# mf = ModelFrame(@formula(y ~ 1 + Sex).rhs, dfInd)\nZ = modelmatrix(frml, refTG2, hints = contrasts);","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"# Y matrix\nY = Matrix(metabolitesTG)[:, 2:end]; # Remove first column","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"@mlmFormula are similar with the @formula from the package StatsModels. The mlmFormula macro takes expression like 1 + a*b to construct design matrix.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"Operators that have special interpretations in this syntax are:","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"+ concatenates variables as columns when generating a model matrix.\n& representes an interaction between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).\n* expands to all main effects and interactions: a*b is equivalent to a+b+a&b, a*b*c to a+b+c+a&b+a&c+b&c+a&b&c, etc.\n1, 0, and -1 indicate the presence (for 1) or absence (for 0 and -1) of an intercept column.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"dat = RawData(Response(Y), Predictors(X_1, Z, false,  false)) # Build raw data object\n# Matrix linear model estimation, we already add an intercept when building design matrix\nest = mlm(dat, addXIntercept=false, addZIntercept=false) \nesti_coef = MatrixLM.coef(est);","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"After the model estimation, we will use permutation test to calculate t statistics and p value.","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"nPerms = 5\n# confusing about specifying again intercept boolean\ntStats, pVals = mlm_perms(dat, nPerms, addXIntercept=false, addZIntercept=false);","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"znames = [\"Total_C:1\" \"Total_C:2\" \"Total_C:3\"]\nplot(permutedims(tStats)[:,1], markershape = :circle, legend = false, title = \"T-statistics of coefficient estimation\", \n    xticks = (collect(1:length(znames)), znames))","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"(Image: svg)","category":"page"},{"location":"moreExamples/","page":"More examples","title":"More examples","text":"From the model above, the triglycerides of all carbon numbers are significantly different between the people without diabeties and with diabeties.","category":"page"},{"location":"getting_started/#Overview","page":"Getting Started","title":"Overview","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The matrix linear model is a simple, yet flexible, multivariate framework. It encodes both categorical and continuous relationships to enhance detection of associations between responses and predictors. For matrix linear model, let Y be a n times m response matrix, the model can be expressed as: ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Y = XBZ^T+E","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Where X_n times p is the matrix for main predictor, Z_m times q denote the matrix from extra knowledge, E_n times m is the error term,  B_p times q is the matrix for main and interaction effects.","category":"page"},{"location":"getting_started/#Data-Generation","page":"Getting Started","title":"Data Generation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, construct a RawData object consisting of the response variable Y and row/column predictors X and Z. All three matrices must be passed in as 2-dimensional arrays. Note that the contr function can be used to set up treatment and/or sum contrasts for categorical variables stored in a DataFrame. By default, contr generates treatment contrasts for all specified categorical variables (\"treat\"). Other options include \"sum\" for sum contrasts, \"noint\" for treatment contrasts with no intercept, and \"sumnoint\" for sum contrasts with no intercept. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using MatrixLM, DataFrames, Random, Plots, StatsModels\nRandom.seed!(1)\n\n# Dimensions of matrices \nn = 100\nm = 250\n\n# Number of column covariates\nq = 20\n\n# Generate data with two categorical variables and 4 numerical variables.\nX_df = hcat(DataFrame(catvar1=rand(1:5, n), catvar2=rand([\"A\", \"B\", \"C\"], n)), DataFrame(rand(n,4),:auto))\n\n# Convert dataframe to predicton matrix\nX = Matrix(contr(X_df, [:catvar1, :catvar2], [\"treat\", \"sum\"]))\n\np = size(X)[2]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Randomly generate some data for column covariates Z and response variable Y","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Z = rand(m,q)\nB = rand(-5:5,p,q)\nE = randn(n,m)\nY = X*B*transpose(Z)+E","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, using all the data we have to construct a RawData object. The usage of RawData() can be found in here.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Construct a RawData object\ndat = RawData(Response(Y), Predictors(X, Z))","category":"page"},{"location":"getting_started/#Modelling","page":"Getting Started","title":"Modelling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The matrix linear model could be build by using RawData object directly.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Least-squares estimates for matrix linear models can be obtained by running mlm(). An object of type Mlm will be returned, with variables for the coefficient estimates (B), the coefficient variance estimates (varB), and the estimated variance of the errors (ùúé). By default, mlm estimates both row and column main effects (X and Z intercepts), but this behavior can be suppressed by setting addXIntercept=false and/or addZIntercept=false. Column weights for Y and the target type for variance shrinkage can be optionally supplied to weights and targetType, respectively.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"est = mlm(dat) # Model estimation","category":"page"},{"location":"getting_started/#Model-prediction-and-residuals","page":"Getting Started","title":"Model prediction and residuals","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The coefficient estimates can be accessed using coef(est). Predicted values and residuals can be obtained by calling predict() and resid(). By default, both of these functions use the same data used to fit the model. However, a new Predictors object can be passed into predict() as the newPredictors argument and a new RawData object can be passed into resid() as the newData argument. For convenience, fitted(est) will return the fitted values by calling predict with the default arguments.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"esti_coef = coef(est) # Get the coefficients of the model","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"preds = predict(est) # Prediction value","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"resids = resid(est)\nhistogram((reshape(resids,250*100,1)), title = \"Distribution of the residuals\", label = \"resid\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(Y)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(preds.Y)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(X)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/#T-statistics-and-permutation-test","page":"Getting Started","title":"T-statistics and permutation test","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The t-statistics for an Mlm object (defined as est.B ./ sqrt.(est.varB)) can be obtained by running t_stat. By default, t_stat does not return the corresponding t-statistics for any main effects that were estimated by mlm, but they will be returned if isMainEff=true. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"tStats = t_stat(est)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"10√ó20 Matrix{Float64}:\n  55.0593    15.5157    -13.7332  ‚Ä¶  -13.4822   16.9667    -72.7102\n -43.2127   -85.3564    -61.2276      74.6016   15.8811    -63.506\n   1.04613  -30.0836    -28.961       70.9267  -29.3495    -14.8734\n  56.3955    48.2328     27.4123      56.6471  -42.5652    -44.6496\n -32.2053   185.189      68.339       99.0601  -35.7229    -35.7794\n  96.4889   -75.9443    101.425   ‚Ä¶  -99.4465  -68.6703   -141.992\n -64.0735     0.278908  -40.5377      39.4619  -40.0343    -68.9459\n -51.9953   -17.1299     15.8784      54.0004   -1.20985    29.7277\n  66.1145    14.0632    -28.4093      15.099   -15.5784    -44.3614\n -54.151      0.125609   38.8427      68.1343  -44.1664    -41.4959","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Permutation p-values for the t-statistics can be computed by the mlm_perms function. mlm_perms calls the more general function perm_pvals and will run the permutations in parallel when possible. The illustrative example below only runs 5 permutations, but a different number can be specified as the second argument. By default, the function used to permute Y is shuffle_rows, which shuffles the rows for Y. Alternative functions for permuting Y, such as shuffle_cols, can be passed into the argument permFun. mlm_perms calls mlm and t_stat , so the user is free to specify keyword arguments for mlm or t_stat; by default, mlm_perms will call both functions using their default behavior. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"nPerms = 5\ntStats, pVals = mlm_perms(dat, nPerms)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After the modeling, we can compare the difference between model estimation effect and the effect matrix that we generated.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(tStats)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(pVals)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(B)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"heatmap(esti_coef[1:end .!= 1, 1:end .!= 1]) # remove auto generated intercepts","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: svg)","category":"page"},{"location":"#MatrixLM","page":"Home","title":"MatrixLM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: MIT license) (Image: Documentation) (Image: Pkg Status)","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can estimates matrix linear models. The core functions to obtain closed-form least squares estimates for matrix linear models. Variance shrinkage is adapted from Ledoit & Wolf (2003).","category":"page"},{"location":"","page":"Home","title":"Home","text":"An extension of MatrixLM for applications in high-throughput genetic screens is the GeneticScreens package. See the associated paper, \"Matrix linear models for high-throughput chemical genetic screens\", and its reproducible code for more details. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MatrixLMnet is a related package that implements algorithms for  L1-penalized estimates for matrix linear models. See the associated paper, \"Sparse matrix linear models for structured high-throughput data\", and its reproducible code for more details. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The MatrixLM package can be installed by running: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MatrixLM\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the most recent version, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/senresearch/MatrixLM.jl\", rev=\"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can also install MatrixLM from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add MatrixLM","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"#Questions","page":"Home","title":"Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about contributing or using MatrixLM package, please communicate with authors form github.","category":"page"},{"location":"#Citing-MatrixLM","page":"Home","title":"Citing MatrixLM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use MatrixLM in a scientific publication, please consider citing following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jane W Liang, Robert J Nichols, ≈öaunak Sen, Matrix Linear Models for High-Throughput Chemical Genetic Screens, Genetics, Volume 212, Issue 4, 1 August 2019, Pages 1063‚Äì1073, https://doi.org/10.1534/genetics.119.302299","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{10.1534/genetics.119.302299,\n    author = {Liang, Jane W and Nichols, Robert J and Sen, ≈öaunak},\n    title = \"{Matrix Linear Models for High-Throughput Chemical Genetic Screens}\",\n    journal = {Genetics},\n    volume = {212},\n    number = {4},\n    pages = {1063-1073},\n    year = {2019},\n    month = {06},\n    issn = {1943-2631},\n    doi = {10.1534/genetics.119.302299},\n    url = {https://doi.org/10.1534/genetics.119.302299},\n    eprint = {https://academic.oup.com/genetics/article-pdf/212/4/1063/42105135/genetics1063.pdf},\n}","category":"page"}]
}
