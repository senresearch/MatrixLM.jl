<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example: MLM for ordinal data · MatrixLM.jl</title><meta name="title" content="Example: MLM for ordinal data · MatrixLM.jl"/><meta property="og:title" content="Example: MLM for ordinal data · MatrixLM.jl"/><meta property="twitter:title" content="Example: MLM for ordinal data · MatrixLM.jl"/><meta name="description" content="Documentation for MatrixLM.jl."/><meta property="og:description" content="Documentation for MatrixLM.jl."/><meta property="twitter:description" content="Documentation for MatrixLM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixLM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Example: MLM for ordinal data</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Data-Generation"><span>Data Generation</span></a></li><li><a class="tocitem" href="#Model-estimation"><span>Model estimation</span></a></li><li><a class="tocitem" href="#Model-predictions-and-residuals"><span>Model predictions and residuals</span></a></li><li><a class="tocitem" href="#T-statistics-and-permutation-test"><span>T-statistics and permutation test</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Types and Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example: MLM for ordinal data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example: MLM for ordinal data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/MatrixLM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/MatrixLM.jl/blob/main/docs/src/example_ordinal_data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>In this example, we&#39;ll showcase the use of Matrix Linear Models (MLM) when dealing with ordinal data as predictors, specifically when the differences between sequential levels of the variable are of interest. To illustrate this, we&#39;ll create a simulated dataset where our X matrix comprises a single ordinal variable, <code>catvar</code>. This variable ranges from 1 to 5. This simple setup will clearly demonstrate how MLM can handle ordinal data.</p><p>Just as a quick recap, our model formula is:</p><p class="math-container">\[Y = XBZ^T+E\]</p><p>In this equation:</p><ul><li><span>$Y_{n \times m}$</span> is the response matrix</li><li><span>$X_{n \times p}$</span> is the matrix for main predictors,</li><li><span>$Z_{m \times q}$</span> denote the response attributes matrix based on supervised knowledge,</li><li><span>$E_{n \times m}$</span> is the error term, </li><li><span>$B_{p \times q}$</span> is the matrix for main and interaction effects.</li></ul><p>This model formulation concisely summarizes the interactions between various elements in the matrix linear model framework.</p><h2 id="Data-Generation"><a class="docs-heading-anchor" href="#Data-Generation">Data Generation</a><a id="Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Generation" title="Permalink"></a></h2><p>Our dataset is made up of a dataframe <code>X</code> that includes a single predictor. This predictor is ordinal data with <code>5 levels</code>, distributed over <code>n = 100</code> samples. Next, we define a response dataframe <code>Y</code> that consists of <code>m = 250</code> responses.  In order to simulate the <code>Y</code> data, we need to construct the matrices <code>Z</code>, <code>B</code>, and <code>E</code>. The <code>Z</code> matrix imparts information about the response population, represented by the columns of <code>Y</code>, <span>$y_{i \in [1, 250]}$</span>. This matrix is given dimensions of <code>250x4</code>.</p><p>In accordance with this configuration, our coefficient matrix <code>B</code> is set to have dimensions of <code>4x5</code>, aligning with the number of predictors in the design matrix <code>X</code> and the number of information categories in <code>Z</code>.</p><p>Lastly, we formulate the noise matrix E that accommodates the error terms. This matrix is produced as a normally distributed matrix (<span>$N, 0, 1$</span>), introducing a degree of variability into our simulation.</p><pre><code class="language-julia hljs">using MatrixLM, DataFrames, Random, Plots, StatsModels, Statistics
Random.seed!(1)

# Dimensions of matrices
n = 100
m = 250

# Number of groupings designed in the Z matrix
q = 4

# Generate data with 1 ordinal categorical variable.
dfX = DataFrame(catvar=rand(1:5, n));
levels_catvar = sort(unique(dfX.catvar));</code></pre><p>We employ the <a href="../functions/#MatrixLM.design_matrix-Tuple{Any, DataFrames.DataFrame, Dict}"><code>design_matrix()</code></a> function to derive the predictor design matrix and apply contrast coding using the <code>StatsModels.SeqDiffCoding()</code> system. This coding system is particularly useful for testing hypotheses related to &quot;sequential differences&quot; between the levels of our ordinal predictor.</p><pre><code class="language-julia hljs">X_ctrst = Dict(:catvar =&gt; SeqDiffCoding(levels = levels_catvar));
X = design_matrix(@mlmformula(1 + catvar), dfX, X_ctrst);
p = size(X, 2);</code></pre><p>The design matrix <code>X</code> has <code>p = 5</code> columns defined as:</p><pre><code class="language-julia hljs">X_names = MatrixLM.design_matrix_names(@mlmformula(1 + catvar), dfX, X_ctrst);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{String}:
 &quot;(Intercept)&quot;
 &quot;catvar: 2&quot;
 &quot;catvar: 3&quot;
 &quot;catvar: 4&quot;
 &quot;catvar: 5&quot;</code></pre><p>We randomly generate a dataframe <code>Z</code> that provides information about whether a response <span>$y_{i \in [1, 250]}$</span>, i.e., a column of <code>Y</code>, exhibits one of the four mutually exclusive attributes <code>{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}</code>. To extract the design matrix of this &quot;column predictor,&quot; we use the <a href="../functions/#MatrixLM.design_matrix-Tuple{Any, DataFrames.DataFrame, Dict}"><code>design_matrix()</code></a> function and implement contrast coding with the <code>StatsModels.FullDummyCoding()</code> system.</p><p>The <code>StatsModels.FullDummyCoding()</code> system generates one indicator (1 or 0) column for each level, <strong>including</strong> the base level. This technique is sometimes referred to as one-hot encoding, which is widely used for categorical variables.</p><pre><code class="language-julia hljs">dfZ = DataFrame(attribute = rand([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], m));
Z_ctrst = Dict(:attribute =&gt; StatsModels.FullDummyCoding());
Z = design_matrix(@mlmformula(0 + attribute), dfZ, Z_ctrst);</code></pre><p>The design matrix <code>Z</code> has <code>q = 4</code> columns defined as:</p><pre><code class="language-julia hljs">Z_names = MatrixLM.design_matrix_names(@mlmformula(0 + attribute), dfZ, Z_ctrst);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 &quot;attribute: A&quot;
 &quot;attribute: B&quot;
 &quot;attribute: C&quot;
 &quot;attribute: D&quot;</code></pre><p>The error matrix <code>E</code> is obtained as follows:</p><pre><code class="language-julia hljs">E = randn(n, m) .* 4;</code></pre><p>We intentionally structure the coefficient matrix <code>B</code> according to a distinct pattern. By doing so, we enable a more straightforward visualization and interpretation of the results in the following steps:</p><pre><code class="language-julia hljs"># (p, q)
B = [
    20.0  10.0 15.0 12.0;
    0.01  7.0  0.05 0.01;
    12.0  0.1  0.05 0.5;
    0.01  12.0 0.05 0.03;
    0.07  0.0  8.5  0.04;
];</code></pre><p>Generate the response matrix <code>Y</code>:</p><pre><code class="language-julia hljs">Y = X*B*Z&#39; + E;</code></pre><p>Now, construct the <code>RawData</code> object consisting of the response variable <code>Y</code> and row/column predictors <code>X</code> and <code>Z</code>. All three matrices must be passed in as 2-dimensional arrays. You have the option to specify if <code>X</code> and <code>Z</code> include an intercept (true) or not (false). If this information is not provided, the default setting is assumed to be false (no intercept).</p><pre><code class="language-julia hljs"># Construct a RawData object
dat = RawData(Response(Y), Predictors(X, Z, true, false));</code></pre><h2 id="Model-estimation"><a class="docs-heading-anchor" href="#Model-estimation">Model estimation</a><a id="Model-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-estimation" title="Permalink"></a></h2><p>Least-squares estimates for matrix linear models can be obtained by running <code>mlm</code>. An object of type <code>Mlm</code> will be returned, with variables for the coefficient estimates (<code>B</code>), the coefficient variance estimates (<code>varB</code>), and the estimated variance of the errors (<code>sigma</code>). By default, <code>mlm</code> estimates both row and column main effects (X and Z intercepts), but this behavior can be suppressed by setting <code>addXIntercept=false</code> and/or <code>addZIntercept=false</code>. Column weights for <code>Y</code> and the target type for variance shrinkage<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> can be optionally supplied to <code>weights</code> and <code>targetType</code>, respectively. </p><pre><code class="language-julia hljs">est = mlm(dat; addXIntercept=false, addZIntercept=false); # Model estimation</code></pre><h2 id="Model-predictions-and-residuals"><a class="docs-heading-anchor" href="#Model-predictions-and-residuals">Model predictions and residuals</a><a id="Model-predictions-and-residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Model-predictions-and-residuals" title="Permalink"></a></h2><p>The coefficient estimates can be accessed using <code>coef(est)</code>. Predicted values and residuals can be obtained by calling <code>predict()</code> and <code>resid()</code>. By default, both of these functions use the same data used to fit the model. However, a new <code>Predictors</code> object can be passed into <code>predict()</code> as the <code>newPredictors</code> argument and a new <code>RawData</code> object can be passed into <code>resid()</code> as the newData argument. For convenience, <code>fitted(est)</code> will return the fitted values by calling predict with the default arguments.</p><pre><code class="language-julia hljs">esti_coef = coef(est); # Get the coefficients of the model</code></pre><p>To compare the estimated coefficients with the original matrix <code>B</code>, we will visualize the matrices using heatmaps. This graphical representation allows us to readily see differences and similarities between the two.</p><pre><code class="language-julia hljs">plot(
    heatmap(B[end:-1:1, :],
            size = (800, 300)),
    heatmap(esti_coef[end:-1:1, :],
            size = (800, 300)),
    title = [&quot;\$ \\mathbf{B}\$&quot; &quot;\$ \\mathbf{\\hat{B}}\$&quot;]
)</code></pre><img src="73a74cff.svg" alt="Example block output"/><p>Let&#39;s employ the same visualization method to compare the predicted values with the original <code>Y</code> response matrix. This allows us to gauge the accuracy of our model predictions.</p><pre><code class="language-julia hljs">preds = predict(est); # Prediction value

plot(
    heatmap(Y[end:-1:1, :],
            size = (800, 300)),
    heatmap(preds.Y[end:-1:1, :],
            size = (800, 300),
            # clims = (-2, 8)
            ),
    title = [&quot;\$ \\mathbf{Y}\$&quot; &quot;\$ \\mathbf{\\hat{Y}}\$&quot;]
)</code></pre><img src="a392f97a.svg" alt="Example block output"/><p>The <code>resid()</code> function, available in <code>MatrixLM.jl</code>, provides us with the ability to compute residuals for each observation, helping you evaluate the discrepancy between the model&#39;s predictions and the actual data.</p><pre><code class="language-julia hljs">resids = resid(est);

plot(
    heatmap(resids[end:-1:1, :],
            size = (800, 300)),
    histogram(
        (reshape(resids,250*100,1)),
            grid  = false,
            label = &quot;&quot;,
            size = (800, 300)),
    title = [&quot;Residuals&quot; &quot;Distribution of the residuals&quot;]
)</code></pre><img src="78c9919f.svg" alt="Example block output"/><h2 id="T-statistics-and-permutation-test"><a class="docs-heading-anchor" href="#T-statistics-and-permutation-test">T-statistics and permutation test</a><a id="T-statistics-and-permutation-test-1"></a><a class="docs-heading-anchor-permalink" href="#T-statistics-and-permutation-test" title="Permalink"></a></h2><p>The t-statistics for an <code>Mlm</code> object (defined as <code>est.B ./ sqrt.(est.varB)</code>) can be obtained by running <code>t_stat</code>. By default, <code>t_stat</code> does not return the corresponding t-statistics for any main effects that were estimated by <code>mlm</code>, but they will be returned if <code>isMainEff=true</code>.</p><pre><code class="language-julia hljs">tStats = t_stat(est);</code></pre><p>Permutation p-values for the t-statistics can be computed by the <code>mlm_perms</code> function. <code>mlm_perms</code> calls the more general function <code>perm_pvals</code> and will run the permutations in parallel when possible. The illustrative example below only runs 5 permutations, but a different number can be specified as the second argument. By default, the function used to permute <code>Y</code> is <code>shuffle_rows</code>, which shuffles the rows for <code>Y</code>. Alternative functions for permuting <code>Y</code>, such as <code>shuffle_cols</code>, can be passed into the argument <code>permFun</code>. <code>mlm_perms</code> calls <code>mlm</code> and <code>t_stat</code> , so the user is free to specify keyword arguments for <code>mlm</code> or <code>t_stat</code>; by default, <code>mlm_perms</code> will call both functions using their default behavior.</p><pre><code class="language-julia hljs">nPerms = 500
tStats, pVals = mlm_perms(dat, nPerms, addXIntercept=false, addZIntercept=false);

plot(
    heatmap(tStats[end:-1:1, :],
            c = :bluesreds,
            clims = (-400, 400),
            xticks = (1:4, Z_names),
            xrotation = 45,
            yticks = (collect(5:-1:1), X_names),
            bottom_margin = (10, :mm),
            size = (800, 300)),
    heatmap(-log.(pVals[end:-1:1, :]),
            grid = false,
            xticks = (1:4, Z_names),
            xrotation = 45,
            yticks = (collect(5:-1:1), X_names),
            bottom_margin = (10, :mm),
            size = (800, 300)),
    title = [&quot;T Statistics&quot; &quot;- Log(P-values)&quot;]
)</code></pre><img src="51beba9a.svg" alt="Example block output"/><p>In this example, our interpretation of the results can be as follows:</p><ul><li>the responses <span>$y_{i \in [1, 250]}$</span> that exhibit the &quot;A&quot; attribute in <code>Z</code> show significant differences between level 3 and level 2 of the predictor <code>catvar</code> in <code>X</code>.</li><li>the responses <span>$y_{i \in [1, 250]}$</span> that exhibit the &quot;B&quot; attribute in <code>Z</code> show significant differences between level 4 and level 3, as well as between level 2 and level 1 of the predictor <code>catvar</code> in <code>X</code>.</li><li>the responses <span>$y_{i \in [1, 250]}$</span> that exhibit the &quot;C&quot; attribute in <code>Z</code> show significant differences between level 5 and level 4 of the predictor <code>catvar</code> in <code>X</code>.</li></ul><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Ledoit, O., &amp; Wolf, M. (2003). Improved estimation of the covariance matrix of stock returns with an application to portfolio selection. Journal of empirical finance, 10(5), 603-621. </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../functions/">Types and Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Thursday 12 June 2025 16:47">Thursday 12 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
