var documenterSearchIndex = {"docs":
[{"location":"example_ordinal_data/#Overview","page":"Example: MLM for ordinal data","title":"Overview","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"In this example, we'll showcase the use of Matrix Linear Models (MLM) when dealing with ordinal data as predictors, specifically when the differences between sequential levels of the variable are of interest. To illustrate this, we'll create a simulated dataset where our X matrix comprises a single ordinal variable, catvar. This variable ranges from 1 to 5. This simple setup will clearly demonstrate how MLM can handle ordinal data.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Just as a quick recap, our model formula is:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Y = XBZ^T+E","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"In this equation:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Y_n times m is the response matrix\nX_n times p is the matrix for main predictors,\nZ_m times q denote the response attributes matrix based on supervised knowledge,\nE_n times m is the error term, \nB_p times q is the matrix for main and interaction effects.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"This model formulation concisely summarizes the interactions between various elements in the matrix linear model framework.","category":"page"},{"location":"example_ordinal_data/#Data-Generation","page":"Example: MLM for ordinal data","title":"Data Generation","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Our dataset is made up of a dataframe X that includes a single predictor. This predictor is ordinal data with 5 levels, distributed over n = 100 samples. Next, we define a response dataframe Y that consists of m = 250 responses.  In order to simulate the Y data, we need to construct the matrices Z, B, and E. The Z matrix imparts information about the response population, represented by the columns of Y, y_i in 1 250. This matrix is given dimensions of 250x4.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"In accordance with this configuration, our coefficient matrix B is set to have dimensions of 4x5, aligning with the number of predictors in the design matrix X and the number of information categories in Z.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Lastly, we formulate the noise matrix E that accommodates the error terms. This matrix is produced as a normally distributed matrix (N 0 1), introducing a degree of variability into our simulation.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"using MatrixLM, DataFrames, Random, Plots, StatsModels, Statistics\nRandom.seed!(1)\n\n# Dimensions of matrices \nn = 100\nm = 250\n\n# Number of groupings designed in the Z matrix\nq = 4\n\n# Generate data with 1 ordinal categorical variable.\ndfX = DataFrame(catvar=rand(1:5, n));\nlevels_catvar = sort(unique(dfX.catvar));\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"We employ the design_matrix() function to derive the predictor design matrix and apply contrast coding using the StatsModels.SeqDiffCoding() system. This coding system is particularly useful for testing hypotheses related to \"sequential differences\" between the levels of our ordinal predictor.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"X_ctrst = Dict(:catvar => SeqDiffCoding(levels = levels_catvar));\nX = design_matrix(@mlmformula(1 + catvar), dfX, X_ctrst);\np = size(X, 2);\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The design matrix X has p = 5 columns defined as:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"X_names = MatrixLM.design_matrix_names(@mlmformula(1 + catvar), dfX, X_ctrst);","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"We randomly generate a dataframe Z that provides information about whether a response y_i in 1 250, i.e., a column of Y, exhibits one of the four mutually exclusive attributes {\"A\", \"B\", \"C\", \"D\"}. To extract the design matrix of this \"column predictor,\" we use the design_matrix() function and implement contrast coding with the StatsModels.FullDummyCoding() system.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The StatsModels.FullDummyCoding() system generates one indicator (1 or 0) column for each level, including the base level. This technique is sometimes referred to as one-hot encoding, which is widely used for categorical variables.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"dfZ = DataFrame(attribute = rand([\"A\", \"B\", \"C\", \"D\"], m));\nZ_ctrst = Dict(:attribute => StatsModels.FullDummyCoding());\nZ = design_matrix(@mlmformula(0 + attribute), dfZ, Z_ctrst);\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The design matrix Z has q = 4 columns defined as:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Z_names = MatrixLM.design_matrix_names(@mlmformula(0 + attribute), dfZ, Z_ctrst);","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The error matrix E is obtained as follows:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"E = randn(n, m) .* 4;\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"We intentionally structure the coefficient matrix B according to a distinct pattern. By doing so, we enable a more straightforward visualization and interpretation of the results in the following steps:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"# (p, q)\nB = [\n    20.0  10.0 15.0 12.0;\n    0.01  7.0  0.05 0.01;\n    12.0  0.1  0.05 0.5;\n    0.01  12.0 0.05 0.03;\n    0.07  0.0  8.5  0.04;\n];\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Generate the response matrix Y:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Y = X*B*Z' + E;\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Now, construct the RawData object consisting of the response variable Y and row/column predictors X and Z. All three matrices must be passed in as 2-dimensional arrays. You have the option to specify if X and Z include an intercept (true) or not (false). If this information is not provided, the default setting is assumed to be false (no intercept).","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"# Construct a RawData object\ndat = RawData(Response(Y), Predictors(X, Z, true, false));\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/#Model-estimation","page":"Example: MLM for ordinal data","title":"Model estimation","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Least-squares estimates for matrix linear models can be obtained by running mlm. An object of type Mlm will be returned, with variables for the coefficient estimates (B), the coefficient variance estimates (varB), and the estimated variance of the errors (sigma). By default, mlm estimates both row and column main effects (X and Z intercepts), but this behavior can be suppressed by setting addXIntercept=false and/or addZIntercept=false. Column weights for Y and the target type for variance shrinkage[1] can be optionally supplied to weights and targetType, respectively. ","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"est = mlm(dat; addXIntercept=false, addZIntercept=false); # Model estimation\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/#Model-predictions-and-residuals","page":"Example: MLM for ordinal data","title":"Model predictions and residuals","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The coefficient estimates can be accessed using coef(est). Predicted values and residuals can be obtained by calling predict() and resid(). By default, both of these functions use the same data used to fit the model. However, a new Predictors object can be passed into predict() as the newPredictors argument and a new RawData object can be passed into resid() as the newData argument. For convenience, fitted(est) will return the fitted values by calling predict with the default arguments.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"esti_coef = coef(est); # Get the coefficients of the model\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"To compare the estimated coefficients with the original matrix B, we will visualize the matrices using heatmaps. This graphical representation allows us to readily see differences and similarities between the two.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"plot(\n    heatmap(B[end:-1:1, :],\n            size = (800, 300)),\n    heatmap(esti_coef[end:-1:1, :],\n            size = (800, 300)),\n    title = [\"\\$ \\\\mathbf{B}\\$\" \"\\$ \\\\mathbf{\\\\hat{B}}\\$\"]\n)","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Let's employ the same visualization method to compare the predicted values with the original Y response matrix. This allows us to gauge the accuracy of our model predictions.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"preds = predict(est); # Prediction value\n\nplot(\n    heatmap(Y[end:-1:1, :],\n            size = (800, 300)),\n    heatmap(preds.Y[end:-1:1, :],\n            size = (800, 300),\n            # clims = (-2, 8)\n            ),\n    title = [\"\\$ \\\\mathbf{Y}\\$\" \"\\$ \\\\mathbf{\\\\hat{Y}}\\$\"]\n)","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The resid() function, available in MatrixLM.jl, provides us with the ability to compute residuals for each observation, helping you evaluate the discrepancy between the model's predictions and the actual data.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"resids = resid(est);\n\nplot(\n    heatmap(resids[end:-1:1, :], \n            size = (800, 300)),     \n    histogram(\n        (reshape(resids,250*100,1)),\n            grid  = false,\n            label = \"\",\n            size = (800, 300)),     \n    title = [\"Residuals\" \"Distribution of the residuals\"]\n)","category":"page"},{"location":"example_ordinal_data/#T-statistics-and-permutation-test","page":"Example: MLM for ordinal data","title":"T-statistics and permutation test","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"The t-statistics for an Mlm object (defined as est.B ./ sqrt.(est.varB)) can be obtained by running t_stat. By default, t_stat does not return the corresponding t-statistics for any main effects that were estimated by mlm, but they will be returned if isMainEff=true.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"tStats = t_stat(est);\n\nnothing # hide","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"Permutation p-values for the t-statistics can be computed by the mlm_perms function. mlm_perms calls the more general function perm_pvals and will run the permutations in parallel when possible. The illustrative example below only runs 5 permutations, but a different number can be specified as the second argument. By default, the function used to permute Y is shuffle_rows, which shuffles the rows for Y. Alternative functions for permuting Y, such as shuffle_cols, can be passed into the argument permFun. mlm_perms calls mlm and t_stat , so the user is free to specify keyword arguments for mlm or t_stat; by default, mlm_perms will call both functions using their default behavior.","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"nPerms = 500\ntStats, pVals = mlm_perms(dat, nPerms, addXIntercept=false, addZIntercept=false);\n\nplot(\n    heatmap(tStats[end:-1:1, :],\n            c = :bluesreds,\n            clims = (-400, 400),\n            xticks = (1:4, Z_names),\n            xrotation = 45,\n            yticks = (collect(5:-1:1), X_names),\n            bottom_margin = (10, :mm),\n            size = (800, 300)),  \n    heatmap(-log.(pVals[end:-1:1, :]),\n            grid = false,\n            xticks = (1:4, Z_names),\n            xrotation = 45,\n            yticks = (collect(5:-1:1), X_names),\n            bottom_margin = (10, :mm),\n            size = (800, 300)),\n    title = [\"T Statistics\" \"- Log(P-values)\"]\n)","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"In this example, our interpretation of the results can be as follows:","category":"page"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"the responses y_i in 1 250 that exhibit the \"A\" attribute in Z show significant differences between level 3 and level 2 of the predictor catvar in X.\nthe responses y_i in 1 250 that exhibit the \"B\" attribute in Z show significant differences between level 4 and level 3, as well as between level 2 and level 1 of the predictor catvar in X.\nthe responses y_i in 1 250 that exhibit the \"C\" attribute in Z show significant differences between level 5 and level 4 of the predictor catvar in X.","category":"page"},{"location":"example_ordinal_data/#References","page":"Example: MLM for ordinal data","title":"References","text":"","category":"section"},{"location":"example_ordinal_data/","page":"Example: MLM for ordinal data","title":"Example: MLM for ordinal data","text":"[1]: Ledoit, O., & Wolf, M. (2003). Improved estimation of the covariance matrix of stock returns with an application to portfolio selection. Journal of empirical finance, 10(5), 603-621. ","category":"page"},{"location":"functions/#Index","page":"Types and Functions","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"","category":"page"},{"location":"functions/#Description","page":"Types and Functions","title":"Description","text":"","category":"section"},{"location":"functions/#MatrixLM.Mlm","page":"Types and Functions","title":"MatrixLM.Mlm","text":"Mlm(B::Array{Float64,2}, varB::Array{Float64,2}, sigma::Array{Float64,2},    \n    data::RawData, weights, targetType, lambda::Float64)\n\nType for storing the results of an mlm model fit. \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.Predictors","page":"Types and Functions","title":"MatrixLM.Predictors","text":"Predictors(X::AbstractArray{Float64,2}, Z::AbstractArray{Float64,2},\n           hasXIntercept::Bool, hasZIntercept::Bool)\n\nType for storing predictor (covariate) matrices. Also stores boolean  variables hasXIntercept and hasZIntercept (if they are not supplied, they  default to false). \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.RawData","page":"Types and Functions","title":"MatrixLM.RawData","text":"RawData(response::Response, predictors::Predictors)\n\nType for storing response and predictor matrices\n\nAlso stores dimensions of matrices as n, m, p, and q. \n\nn : number of rows of X = number of rows of Y\nm : number of rows of Z = number of columns of Y\np : number of columns of X\nq : number of columns of Z\n\nThe constructor will compute n, m, p, and q based on the response and  predictor matrices and assert that they are consistent. \n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.Response","page":"Types and Functions","title":"MatrixLM.Response","text":"Response(Y::AbstractArray{Float64,2})\n\nType for storing response matrix\n\n\n\n\n\n","category":"type"},{"location":"functions/#MatrixLM.add_intercept-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.add_intercept","text":"add_intercept(A::AbstractArray{Float64,2})\n\nInsert an intercept column (column of ones) at the beginning of a 2d array. \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with an intercept column\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_coeffs-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_coeffs","text":"calc_coeffs(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, \n            Z::AbstractArray{Float64,2}, XTX::AbstractArray{Float64,2}, \n            ZTZ::AbstractArray{Float64,2})\n\nCalculates the the coefficient estimates\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, with all  categorical variables coded in appropriate contrasts\nY::AbstractArray{Float64,2}: The multivariate response\nZ::AbstractArray{Float64,2}: The column covariates, with all categorical variables coded in appropriate contrasts\nXTX::AbstractArray{Float64,2}: X*transpose(X) product as a 2d array of floats \nZTZ::AbstractArray{Float64,2}: Z*transpose(Z) product as a 2d array of floats \n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_preds!-NTuple{4, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_preds!","text":"calc_preds!(preds::AbstractArray{Float64,2}, \n            X::AbstractArray{Float64,2}, \n            Z::AbstractArray{Float64,2}, \n            B::AbstractArray{Float64,2})\n\nPredict values in place\n\nArguments\n\npreds::AbstractArray{Float64,2}: The predicted values, to be  updated in place\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized  as necessary\nB::AbstractArray{Float64,2}: Coefficient estimates\n\nValue\n\nNone; updates predicted values in place. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_preds-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_preds","text":"calc_preds(X::AbstractArray{Float64,2}, \n           Z::AbstractArray{Float64,2}, \n           B::AbstractArray{Float64,2})\n\nPredict values\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized  as necessary\nB::AbstractArray{Float64,2}: Coefficient estimates\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_resid!-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_resid!","text":"calc_resid!(resid::AbstractArray{Float64,2}, \n                 X::AbstractArray{Float64,2}, \n                 Y::AbstractArray{Float64,2}, \n                 Z::AbstractArray{Float64,2}, \n                 B::AbstractArray{Float64,2})\n\nCalculate residuals in place\n\nArguments\n\nresid: 2d array of floats consisting of the residuals, to be updated in  place\nX: 2d array of floats consisting of the row covariates, standardized as  necessary\nY: 2d array of floats consisting of the multivariate response  observations, standardized as necessary\nZ: 2d array of floats consisting of the column covariates, standardized  as necessary\nB: 2d array of floats consisting of coefficient estimates\n\nValue\n\nNone; updates residuals in place. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_resid-NTuple{4, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_resid","text":"calc_resid(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, \n       Z::AbstractArray{Float64,2}, B::AbstractArray{Float64,2})\n\nCalculate residuals\n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, standardized as  necessary\nY::AbstractArray{Float64,2}: The multivariate response observations, standardized as necessary\nZ::AbstractArray{Float64,2}: The column covariates, standardized as necessary\nB::AbstractArray{Float64,2}: The coefficient estimates\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_sigma-Tuple{AbstractMatrix{Float64}, AbstractString}","page":"Types and Functions","title":"MatrixLM.calc_sigma","text":"calc_sigma(resid::AbstractArray{Float64,2}, targetType::AbstractString)\n\nEstimates variance of errors and the shrinkage coefficient, with variance  shrinkage. \n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType::AbstractString: Indicating the target type toward which to shrink the  variance. Acceptable inputs are \"A\", \"B\", \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nTuple\n\nsigma: 2d array of floats; shrunk estimated variance of errors\nlambda: floating scalar; estimated shrinkage coefficient  (0 = no shrinkage, 1 = complete shrinkage)\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_sigma-Tuple{AbstractMatrix{Float64}, Nothing}","page":"Types and Functions","title":"MatrixLM.calc_sigma","text":"calc_sigma(resid::AbstractArray{Float64,2}, targetType::Nothing)\n\nEstimates variance of errors and the shrinkage coefficient, without variance  shrinkage. \n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType : nothing\n\nValue\n\nTuple\n\nsigma: 2d array of floats; estimated variance of errors\nlambda: 0.0\n\nSome notes\n\nSince this version of calc_sigma does not implement variance shrinkage, the  shrinkage coefficient lambda is 0. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.calc_var-NTuple{5, AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.calc_var","text":"calc_var(X::AbstractArray{Float64,2}, Z::AbstractArray{Float64,2},\n         XTX::AbstractArray{Float64,2}, ZTZ::AbstractArray{Float64,2}, \n         sigma::AbstractArray{Float64,2})\n\nCalculate the variance (diagonal of the covariance matrix) of the coefficient  estimates. \n\nArguments\n\nX::AbstractArray{Float64,2}: The row covariates, with all  categorical variables coded in appropriate contrasts\nZ::AbstractArray{Float64,2}: The column covariates, with all  categorical variables coded in appropriate contrasts\nXTX::AbstractArray{Float64,2}: X*transpose(X) product as a 2d array of floats \nZTZ::AbstractArray{Float64,2}: Z*transpose(Z) product as a 2d array of floats \nsigma::AbstractArray{Float64,2}: 2d array of floats consisting of the estimated sigma\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.center-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.center","text":"center(A::AbstractArray{Float64,2})\n\nCenters columns of a 2d array\n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.coef-Tuple{Mlm}","page":"Types and Functions","title":"MatrixLM.coef","text":"coef(MLM::Mlm)\n\nExtracts coefficients from Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.contr","page":"Types and Functions","title":"MatrixLM.contr","text":"contr(df::DataFrames.DataFrame, cVars::AbstractArray{Symbol,1}, \n      cTypes::AbstractArray{String,1}=repeat([\"treat\"], inner=length(cVars)), \n      trtRefs::AbstractArray= repeat([nothing], inner=length(cVars)))\n\nConverts categorical variables in a DataFrame to specified contrast types.  All other variables are left as-is. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncTypes::AbstractArray{String,1}: 1d array of character strings of the same length as cVars,  indicating the types of contrasts to use. Defaults to treatment contrasts  (\"treat\") for all variables in cVars. Other options include \"sum\" for sum  contrasts, \"noint\" for treatment contrasts with no intercept, and  \"sumnoint\" for sum contrasts with no intercept. For \"treat\" cTypes, you  can also specify the level to use as the reference treatment using trtRefs. \ntrtRefs::AbstractArray: optional 1d array of character strings of the same length as  cVars, specifying the level to use as the references for treatment  contrasts. Defaults to nothing for all variables in cVars.\n\nValue\n\nDataFrame with same variables as the original DataFrame, but categorical  variables converted to dummy contrasts. \n\nSome notes\n\nIf cVars consists of only an empty Symbol, i.e. cVars=[Symbol()], this  will signal to the function that no contrasts should be created. The  original DataFrame will be returned. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.cov_est-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.cov_est","text":"cov_est(resid::AbstractArray{Float64,2})\n\nEstimates error variance and its variance/covariance\n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\n\nValue\n\nTuple\n\nest: 2d array of floats; estimate\nvarest: 2d array of floats; variance/covariance estimate\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.design_matrix-Tuple{Any, DataFrames.DataFrame, Dict}","page":"Types and Functions","title":"MatrixLM.design_matrix","text":"design_matrix(frml, df::DataFrame,cntrst::Dict{Symbol, AbstractContrasts})\n\nReturns the design matrix based on the formula terms and the data source.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n- `cntrst`: dictionnary describing encoding method for categorical or ordinal variables, based on `StatsModels.jl`\n\n\n\ndesign_matrix(frml, df::DataFrame, cntrst::Vector)\n\nReturns the design matrix based on the formula terms and the data source.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n- `cntrst`: A vector containing tuples of variable names and corresponding  encoding function.\n\n\n\ndesign_matrix(frml, df::DataFrame)\n\nReturns the default design matrix based on the formula terms and the data source, where\nall the categorical variables are dummy coded.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.design_matrix_names-Tuple{Any, DataFrames.DataFrame, Dict}","page":"Types and Functions","title":"MatrixLM.design_matrix_names","text":"design_matrix_names(frml, df,cntrst::Dict{Symbol, AbstractContrasts})\n\nReturns the columns names of the design matrix based on the formula terms and the data source.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n- `cntrst`: dictionnary describing encoding method for categorical or ordinal variables, based on `StatsModels.jl`\n\n\n\ndesign_matrix_names(frml, df::DataFrame, cntrst::Vector)\n\nReturns the design matrix based on the formula terms and the data source.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n- `cntrst`: A vector containing tuples of variable names and corresponding  encoding function.\n\n\n\ndesign_matrix_names(frml, df::DataFrame)\n\nReturns the columns names of the design matrix based on the formula terms and the data source, where\nall the categorical variables are dummy coded.\n\n# Arguments \n\n- `frml`: formula terms generated by the macro `@mlmformula`\n- `df`: dataframe containing the data source table\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::AbstractArray{Float64,2})\n\nGet the diagonal of a 2d array of floats. This just calls the base diag  function.\n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\n1d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{AbstractVector{Float64}}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::AbstractArray{Float64,1})\n\nGet the diagonal of a 1d array of floats. Behaves like an identity function  (returns itself). \n\nArguments\n\nA::AbstractArray{Float64,1}: 1d array of floats\n\nValue\n\n1d array of floats \n\nSome notes\n\nOriginally intended for use when A is a 1 by 1 array, so may have unintended  consequences for a 1d array of length > 1. \n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.diagonal-Tuple{Float64}","page":"Types and Functions","title":"MatrixLM.diagonal","text":"diagonal(A::Float64)\n\nGet the diagonal of a single scalar (float) value. Behaves like an identity  function (returns itself). \n\nArguments\n\nA::Float64: floating scalar\n\nValue\n\nFloating scalar\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.fitted-Tuple{Mlm}","page":"Types and Functions","title":"MatrixLM.fitted","text":"fitted(MLM::Mlm)\n\nCalculate fitted values of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\n\nValue\n\nResponse object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_X-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_X","text":"get_X(data::RawData)\n\nExtract X matrix from RawData object \n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_Y-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_Y","text":"get_Y(data::RawData)\n\nExtract Y matrix from RawData object\n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_Z-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.get_Z","text":"get_Z(data::RawData)\n\nExtract Z matrix from RawData object\n\nArguments\n\ndata::RawData: RawData object\n\nValue\n\n2d array\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_dummy-Tuple{DataFrames.DataFrame, Symbol, String, Nothing}","page":"Types and Functions","title":"MatrixLM.get_dummy","text":"get_dummy(df::DataFrames.DataFrame, cVar::Symbol, \n          cType::String, trtRef::Nothing)\n\nConvert categorical variable to dummy indicators using specified contrast  type. This covers all cases except for treatment contrasts with a specified  reference level. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncType::String: character string indicating the type of contrast to use for cVar\ntrtRef::Nothing: nothing\n\nValue\n\nDataFrame of dummy variables for the specified categorical variable\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.get_dummy-Tuple{DataFrames.DataFrame, Symbol, String, String}","page":"Types and Functions","title":"MatrixLM.get_dummy","text":"get_dummy(df::DataFrames.DataFrame, cVar::Symbol, \n          cType::String, trtRef::String)\n\nConvert categorical variables to for treatment contrasts with a specified  reference level. \n\nArguments\n\ndf::DataFrames.DataFrame: DataFrame of variables\ncVar::Symbol: symbol for the categorical variable in df to be converted\ncType::String: character string indicating the type of contrast to use for cVar\ntrtRef::String: character string specifying the level in cVar to use as the reference \n\nValue\n\nDataFrame of dummy variables for the specified categorical variable\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.kron_diag-Tuple{Any, Any}","page":"Types and Functions","title":"MatrixLM.kron_diag","text":"kron_diag(A, B)\n\nCompute the diagonal of the Kronecker product of arrays or scalars\n\nArguments\n\nA: square 2d array of floats, a 1d array of floats, or a scalar\nB: square 2d array of floats, a 1d array of floats, or a scalar\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm-Tuple{RawData}","page":"Types and Functions","title":"MatrixLM.mlm","text":"mlm(data::RawData; addXIntercept::Bool=true, addZIntercept::Bool=true, weights=nothing, targetType=nothing)\n\nMatrix linear model using least squares method. Column weighted least squares  and shrinkage of the variance of the errors are options. \n\nArguments\n\ndata::RawData: RawData object\n\nKeyword arguments\n\naddXIntercept::Bool : boolean flag indicating whether or not to include an X  intercept (row main effects). Defaults to true. \naddZIntercept::Bool : boolean flag indicating whether or not to include a Z  intercept (column main effects). Defaults to true. \nweights : 1d array of floats to use as column weights for Y, or nothing.  If the former, must be the same length as the number of columns of Y.  Defaults to nothing. \ntargetType : string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". Defaults to nothing. \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_fit-Tuple{RawData, Nothing, Any}","page":"Types and Functions","title":"MatrixLM.mlm_fit","text":"mlm_fit(data::RawData, weights::Nothing, targetType)\n\nMatrix linear model using least squares method. Optionally incorporates  shrinkage of the variance of the errors. \n\nArguments\n\ndata::RawData: RawData object\nweights::Nothing: nothing\ntargetType: string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_fit-Tuple{RawData, Vector{Float64}, Any}","page":"Types and Functions","title":"MatrixLM.mlm_fit","text":"mlm_fit(data::RawData, weights::Array{Float64,1}, targetType)\n\nMatrix linear model using column weighted least squares method. Optionally  incorporates shrinkage of the variance of the errors. \n\nArguments\n\ndata::RawData : RawData object\nweights::Array{Float64,1} : 1d array of floats to use as column weights for Y. Must be the  same length as the number of columns of Y. \ntargetType : string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nAn Mlm object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.mlm_perms","page":"Types and Functions","title":"MatrixLM.mlm_perms","text":"mlm_perms(data::RawData, nPerms::Int64=1000; \n          permFun::Function=shuffle_rows, \n          addXIntercept::Bool=true, addZIntercept::Bool=true, \n          weights=nothing, targetType=nothing, isMainEff::Bool=false)\n\nObtains permutation p-values for MLM t-statistics. \n\nArguments\n\ndata::RawData: RawData object\nnPerms::Int64=1000: Number of permutations. Defaults to 1000.\n\nKeyword arguments\n\npermFun::Function: function used to permute Y. Defaults to shuffle_rows  (shuffles rows of Y). \naddXIntercept::Bool=true: Boolean flag indicating whether or not to include an X  intercept (row main effects). Defaults to true. \naddZIntercept::Bool=true: Boolean flag indicating whether or not to include a Z  intercept (column main effects). Defaults to true. \nweights: 1d array of floats to use as column weights for Y, or nothing.  If the former, must be the same length as the number of columns of Y.  Defaults to nothing. \ntargetType: string indicating the target type toward which to shrink the  error variance, or nothing. If the former, acceptable inputs are \"A\", \"B\",  \"C\", and \"D\". Defaults to nothing.\n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries \nisMainEff::Bool: boolean flag indicating whether or not to include p-values for  the main effects\n\nValue\n\nTuple\n\ntStats: 2d array of floats; t-statistics\npvals: 2d array of floats; permutation p-values\n\nSome notes\n\nPermutations are computed in parallel when possible. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.perm_pvals","page":"Types and Functions","title":"MatrixLM.perm_pvals","text":"perm_pvals(fun::Function, data::RawData, nPerms::Int64=1000; \n           permFun::Function=shuffle_rows, funArgs...)\n\nObtains permutation p-values. \n\nArguments\n\nfun::Function: function that returns a test statistic\ndata::RawData: RawData object\nnPerms::Int64: number of permutations. Defaults to 1000.\n\nKeyword arguments\n\npermFun::Function: function used to permute Y. Defaults to shuffle_rows  (shuffles rows of Y). \nfunArgs: variable keyword arguments to be passed into fun\n\nValue\n\nTuple\n\ntestStats: 2d array of floats; t-statistics\npvals: 2d array of floats; permutation p-values\n\nSome notes\n\nPermutations are computed in parallel when possible. \n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.predict","page":"Types and Functions","title":"MatrixLM.predict","text":"predict(MLM::Mlm, newPredictors::Predictors=MLM.data.predictors)\n\nCalculates new predictions based on Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nnewPredictors::Predictors: Predictors object. Defaults to the data.predictors field  in the Mlm object used to fit the model. \n\nValue\n\nResponse object\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.remove_intercept-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.remove_intercept","text":"remove_intercept(A::AbstractArray{Float64,2})\n\nRemove the intercept column, assumed to be the first column of a 2d array. \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A without the intercept column\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.resid","page":"Types and Functions","title":"MatrixLM.resid","text":"resid(MLM::Mlm, newData::RawData=MLM.data)\n\nCalculates residuals of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nnewData::RawData: RawData object. Defaults to the data field in the Mlm object  used to fit the model. \n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.shrink_sigma-Tuple{AbstractMatrix{Float64}, String}","page":"Types and Functions","title":"MatrixLM.shrink_sigma","text":"shrink_sigma(resid::AbstractArray{Float64,2}, targetType::String)\n\nEstimates variance of errors and the shrinkage coefficient\n\nArguments\n\nresid::AbstractArray{Float64,2}: 2d array of floats consisting of the residuals\ntargetType::String: string indicating the target type toward which to shrink the  variance. Acceptable inputs are \"A\", \"B\", \"C\", and \"D\". \n\"A\": Target is identity matrix\n\"B\": Target is diagonal matrix with constant diagonal\n\"C\": Target is has same diagonal element, and same off-diagonal element\n\"D\": Target is diagonal matrix with unequal entries\n\nValue\n\nTuple\n\nsigma: 2d array of floats; shrunk estimated variance of errors\nlambda: floating scalar; estimated shrinkage coefficient  (0 = no shrinkage, 1 = complete shrinkage)\n\nReference\n\nLedoit, O., & Wolf, M. (2003). Improved estimation of the covariance matrix      of stock returns with an application to portfolio selection. Journal of      empirical finance, 10(5), 603-621.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.shuffle_cols-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.shuffle_cols","text":"shuffle_cols(A::AbstractArray{Float64,2})\n\nShuffles columns of a 2d array \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with columns shuffled\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.shuffle_rows-Tuple{AbstractMatrix{Float64}}","page":"Types and Functions","title":"MatrixLM.shuffle_rows","text":"shuffle_rows(A::AbstractArray{Float64,2})\n\nShuffles rows of a 2d array \n\nArguments\n\nA::AbstractArray{Float64,2}: 2d array of floats\n\nValue\n\nReturns A with rows shuffled\n\n\n\n\n\n","category":"method"},{"location":"functions/#MatrixLM.t_stat","page":"Types and Functions","title":"MatrixLM.t_stat","text":"t_stat(MLM::Mlm, isMainEff::Bool=false)\n\nCalculates t-statistics of an Mlm object\n\nArguments\n\nMLM::Mlm: Mlm object\nisMainEff::Bool : boolean flag indicating whether or not to include t-statistics  for the main effects\n\nValue\n\n2d array of floats\n\n\n\n\n\n","category":"function"},{"location":"functions/#MatrixLM.@mlmformula-Tuple{Any}","page":"Types and Functions","title":"MatrixLM.@mlmformula","text":"mlmformula(ex)\n\nCapture and parse a formula expression for matrix linear model.\n\nThe `@mlmformula` domain-specific language serves the purpose of facilitating table-to-matrix transformations.\nIt is structured to be intuitive for users who have experience with other statistical software.\nAn elementary formula in this language consists of individual terms. These terms may either be symbols that reference\ndata columns or literal numbers `0` or `1`. They are combined by the operators `+`, `&`, and `*`. \nTo ensure correct parsing of the formula, the `@mlmformula`` macro needs to be invoked within parentheses. \nThis macro is built upon the `@formula` macro from the `StatsModels.jl` package.\n\n# Example\n```julia\njulia> @mlmformula(1 + varA * VarB)\n1\nvarA(unknown)\nVarB(unknown)\nvarA(unknown) & VarB(unknown)\n```\n\n\n\n\n\n","category":"macro"},{"location":"getting_started/#Overview","page":"Getting Started","title":"Overview","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this section, we demonstrate how to utilize MatrixLM.jl via a simple example that involves simulated data.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Matrix Linear Models (MLM) serve as a simple yet robust multivariate framework for encoding relationships and groupings within high-throughput data. MLM's flexibility allows it to encode both categorical and continuous relationships, thereby enhancing the detection of associations between responses and predictors.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Within the scope of the matrix linear model framework, the model is articulated as follows:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Y = XBZ^T+E","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Where ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Y_n times m is the response matrix\nX_n times p is the matrix for main predictors,\nZ_m times q denote the response attributes matrix based on a supervised knowledge,\nE_n times m is the error term, \nB_p times q is the matrix for main and interaction effects.","category":"page"},{"location":"getting_started/#Data-Generation","page":"Getting Started","title":"Data Generation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To enhance the practibality of this example, we assume that both the responses and the predictors are presented as dataframes.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Our dataset consists of a dataframe X, which includes p = 5 predictors. Among these predictors, two are categorical variables and three are numerical, spread across n = 100 samples. We then consider a response dataframe Y composed of m = 250 responses. To simulate the Y data, we need to generate the matrices Z,B, and E.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The matrix Z provides information about the response population, which corresponds to the Y's columns y_i in 1 250. The dimensions of this matrix are set at 250x10.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Given this setup, the coefficient matrix B is designed to have dimensions of 5x10. This matches the number of predictors in X and the information categories in Z. Finally, we create the noise matrix E, which contains the error terms. We generate this matrix as a normally-distributed matrix (N 0 4), adding a layer of randomness to our simulation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using MatrixLM, DataFrames, Random, Plots, StatsModels, Statistics\nRandom.seed!(1)\n\n# Dimensions of matrices \nn = 100\nm = 250\n\n# Number of groupings designed in the Z matrix\nq = 10\n\n# Generate data with two categorical variables and 3 numerical variables.\ndfX = hcat(\n        DataFrame(\n            catvar1=string.(rand(0:1, n)),\n            catvar2=rand([\"A\", \"B\", \"C\", \"D\"], n)\n        ),\n        DataFrame(rand(n,3), [\"var3\", \"var4\", \"var5\"])\n    );\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let use the function design_matrix() to get the predictor model matrix based on the formula expression including all the variables terms.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Convert dataframe to predicton matrix\nX = design_matrix(@mlmformula(catvar1 + catvar2 + var3 + var4 + var5), dfX)\np = size(X)[2];\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We also have the option to specify contrast coding in your model. For a detailed understanding of how to implement contrast coding, please refer to the documentation for contrast coding with StatsModels.jl. This will provide you with comprehensive instructions and examples.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Convert dataframe to predicton matrix\nmy_ctrst = Dict(\n             :catvar1 => DummyCoding(base = \"0\"),\n             :catvar2 => DummyCoding(base = \"A\")\n           )\n\nX = design_matrix(@mlmformula(catvar1 + catvar2 + var3 + var4 + var5), dfX, my_ctrst);\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Randomly generate some data for column covariates Z and the error matrix E:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Z = rand(m,q);\nE = randn(n,m) .* 4;\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, we will structure the coefficient matrix B following a specific pattern. This approach will facilitate a more effective visualization of the results in the subsequent steps:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# (p,q)\nB = [\n    2.0   3.0   4.0   5.0  6.0  7.0  8.0  0.0 0.5 -2.0;\n    0.01  0.02  0.01  0.09 0.18 0.03 0.14 0.0 0.5 -2.0;\n    -1.0  -0.5  0.02  0.49 1.1  2.0  5.0  0.0 0.5 -2.0;\n    -0.01 0.02  -0.01 3.0  3.0  7.0  0.14 0.0 0.5 -2.0;\n    0.0   0.0   0.0   0.0  3.0  3.0  3.0  3.0 0.5 -2.0;\n    3.0   3.0   3.0   3.0  0.08 0.03 0.0  0.0 0.5 -2.0;\n    0.01  0.0   3.0   3.0  3.0  3.0 0.04  0.0 0.5 -2.0;\n];\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Generate the response matrix Y:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Y = X*B*Z' + E;\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, construct the RawData object consisting of the response variable Y and row/column predictors X and Z. All three matrices must be passed in as 2-dimensional arrays.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Construct a RawData object\ndat = RawData(Response(Y), Predictors(X, Z));\n\nnothing # hide","category":"page"},{"location":"getting_started/#Model-estimation","page":"Getting Started","title":"Model estimation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Least-squares estimates for matrix linear models can be obtained by running mlm(). An object of type Mlm will be returned, with variables for the coefficient estimates (B), the coefficient variance estimates (varB), and the estimated variance of the errors (sigma). By default, mlm estimates both row and column main effects (X and Z intercepts), but this behavior can be suppressed by setting addXIntercept=false and/or addZIntercept=false. Column weights for Y and the target type for variance shrinkage[1] can be optionally supplied to weights and targetType, respectively. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"est = mlm(dat; addXIntercept=false, addZIntercept=false); # Model estimation\n\nnothing # hide","category":"page"},{"location":"getting_started/#Model-predictions-and-residuals","page":"Getting Started","title":"Model predictions and residuals","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The coefficient estimates can be accessed using coef(). Predicted values and residuals can be obtained by calling predict() and resid(). By default, both of these functions use the same data used to fit the model. However, a new Predictors object can be passed into predict() as the newPredictors argument and a new RawData object can be passed into resid() as the newData argument. For convenience, fitted() will return the fitted values by calling predict with the default arguments.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To compare the estimated coefficients with the original matrix B, we will visualize the matrices using heatmaps. This graphical representation allows us to readily see differences and similarities between the two.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"esti_coef = coef(est); # Get the coefficients of the model\n\nplot(\n    heatmap(B[end:-1:1, :],\n            size = (800, 300)),\n    heatmap(esti_coef[end:-1:1, :],\n            size = (800, 300),\n            clims = (-2, 8)),\n    title = [\"\\$ \\\\mathbf{B}\\$\" \"\\$ \\\\mathbf{\\\\hat{B}}\\$\"]\n)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's employ the same visualization method to compare the predicted values with the original Y response matrix. This allows us to gauge the accuracy of our model predictions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"preds = predict(est); # Prediction value\n\nplot(\n    heatmap(Y[end:-1:1, :],\n            size = (800, 300)),\n    heatmap(preds.Y[end:-1:1, :],\n            size = (800, 300),\n            # clims = (-2, 8)\n            ),\n    title = [\"\\$ \\\\mathbf{Y}\\$\" \"\\$ \\\\mathbf{\\\\hat{Y}}\\$\"]\n)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The resid() function, available in MatrixLM.jl, provides us with the ability to compute residuals for each observation, helping you evaluate the discrepancy between the model's predictions and the actual data.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"resids = resid(est);\n\nplot(\n    heatmap(resids[end:-1:1, :],\n            size = (800, 300)),\n    histogram(\n        (reshape(resids,250*100,1)),\n            grid  = false,\n            label = \"\",\n            size = (800, 300)),\n    title = [\"Residuals\" \"Distribution of the residuals\"]\n)","category":"page"},{"location":"getting_started/#T-statistics-and-permutation-test","page":"Getting Started","title":"T-statistics and permutation test","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The t-statistics for an Mlm object (defined as est.B ./ sqrt.(est.varB)) can be obtained by running t_stat(). By default, t_stat does not return the corresponding t-statistics for any main effects that were estimated by mlm, but they will be returned if isMainEff=true.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"tStats = t_stat(est);\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Permutation p-values for the t-statistics can be computed by the mlm_perms() function. mlm_perms calls the more general function perm_pvals() and will run the permutations in parallel when possible. The illustrative example below only runs 5 permutations, but a different number can be specified as the second argument. By default, the function used to permute Y is shuffle_rows, which shuffles the rows for Y. Alternative functions for permuting Y, such as shuffle_cols, can be passed into the argument permFun. mlm_perms calls mlm and t_stat , so the user is free to specify keyword arguments for mlm or t_stat; by default, mlm_perms will call both functions using their default behavior.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"nPerms = 500\ntStats, pVals = mlm_perms(dat, nPerms);\n\nplot(\n    heatmap(tStats[end:-1:1, :],\n            c = :bluesreds,\n            clims = (-40, 40),\n            size = (800, 300)),\n    heatmap(-log.(pVals[end:-1:1, :]),\n            grid = false,\n            size = (800, 300)),\n    title = [\"T Statistics\" \"- Log(P-values)\"]\n)","category":"page"},{"location":"getting_started/#References","page":"Getting Started","title":"References","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[1]: Ledoit, O., & Wolf, M. (2003). Improved estimation of the covariance matrix of stock returns with an application to portfolio selection. Journal of empirical finance, 10(5), 603-621. ","category":"page"},{"location":"#MatrixLM","page":"Home","title":"MatrixLM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: MIT license) (Image: Stable) (Image: Pkg Status)","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can estimates matrix linear models. The core functions to obtain closed-form least squares estimates for matrix linear models. Variance shrinkage is adapted from Ledoit & Wolf (2003)[1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"An extension of MatrixLM for applications in high-throughput genetic screens is the GeneticScreens package. See the associated paper, \"Matrix linear models for high-throughput chemical genetic screens\", and its reproducible code for more details. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MatrixLMnet is a related package that implements algorithms for  L1-penalized estimates for matrix linear models. See the associated paper, \"Sparse matrix linear models for structured high-throughput data\", and its reproducible code for more details. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The MatrixLM package can be installed by running: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MatrixLM\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or from the julia REPL, press ] to enter pkg mode, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add MatrixLM","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the most recent (development) version, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/senresearch/MatrixLM.jl\", rev=\"main\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"#Questions","page":"Home","title":"Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about contributing or using MatrixLM package, please communicate with the authors via GitHub.","category":"page"},{"location":"#Citing-MatrixLM","page":"Home","title":"Citing MatrixLM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use MatrixLM in a scientific publication, please consider citing the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jane W Liang, Robert J Nichols, Śaunak Sen, Matrix Linear Models for High-Throughput Chemical Genetic Screens, Genetics, Volume 212, Issue 4, 1 August 2019, Pages 1063–1073, https://doi.org/10.1534/genetics.119.302299","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{10.1534/genetics.119.302299,\n    author = {Liang, Jane W and Nichols, Robert J and Sen, Śaunak},\n    title = \"{Matrix Linear Models for High-Throughput Chemical Genetic Screens}\",\n    journal = {Genetics},\n    volume = {212},\n    number = {4},\n    pages = {1063-1073},\n    year = {2019},\n    month = {06},\n    issn = {1943-2631},\n    doi = {10.1534/genetics.119.302299},\n    url = {https://doi.org/10.1534/genetics.119.302299},\n    eprint = {https://academic.oup.com/genetics/article-pdf/212/4/1063/42105135/genetics1063.pdf},\n}","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Ledoit, O., & Wolf, M. (2003). Improved estimation of the covariance matrix of stock returns with an application to portfolio selection. Journal of empirical finance, 10(5), 603-621. ","category":"page"}]
}
